<subsection xml:id="subsec-conversion-ex">
    <title>Example: Converting Fahrenheit to Celsius</title>
    <introduction>
      <p>
        To illustrate some of the issues that arise in using numeric data,
        let's design a program that performs temperature conversions 
        from Fahrenheit to Celsius and vice versa.
      </p>
    </introduction>
   <!-- <subsubsection> -->      
    <paragraphs><title>Problem Decomposition</title></paragraphs>
      <p>
        This problem requires two classes,
        a <c>Temperature</c> class and a <c>TemperatureUI</c> class.
        The <c>Temperature</c> class will perform the temperature conversions,
        and <c>TemperatureUI</c> will serve as the user interface 
        (<xref ref="fig-convapplobjs">Figure</xref>).
      </p>
      <figure xml:id="fig-convapplobjs">
        <caption>Interacting objects: The user interacts with the user
        interface (<c>TemperatureUI</c>), which interacts with the <c>Temperature</c> object.</caption>
        <image width="70%" source="chptr05/f5-2.png"/>
      </figure>
   <!-- </subsubsection> -->
   <paragraphs><title>Class Design: <c>Temperature</c></title></paragraphs>
  
  <!--
    <subsubsection>
      <title>Class Design: <c>Temperature</c></title>
 -->
      <p>
        The purpose of the <c>Temperature</c> class is to perform the temperature conversions.
        To convert a Celsius temperature to  Fahrenheit or vice versa,
        it is not necessary to store the temperature value.
        Rather, a conversion method could take the Celsius
        (or Fahrenheit)
        temperature as a parameter, perform the conversion, and return the result.
        Therefore, the <c>Temperature</c> class does not need any instance variables.
      </p>
      <p>
        Note that in this respect the <c>Temperature</c> class resembles the <c>Math</c> class.
        Unlike <c>OneRowNim</c>, which stores the game's state <mdash/> the number of 
        sticks remaining and whose turn it is <mdash/> the <c>Math</c> 
        and <c>Temperature</c> classes are stateless. They just perform certain calculations
        for us.
      </p>
      <p>
        Thus, following the design of the <c>Math</c> class,
        the <c>Temperature</c> class will have two public static methods:
        one to convert from Fahrenheit to Celsius and one to convert from Celsius to Fahrenheit.
        Recall that static methods are associated with the class rather than with its instances.
        Therefore, we needn't instantiate a <c>Temperature</c> object to use these methods.
        Instead, we can invoke the methods through the class itself.
      </p>
      <p>
        The methods will use the standard conversion formulas:
        <m>F = \frac{9}{5}C + 32</m> and <m>C = \frac{5}{9}(F - 32)</m>.
        Each of these methods should have a single parameter to store the 
        temperature value that is being converted.
      </p>
      <p>
        Because we want to be able to handle temperatures such as 98.6, 
        we should use real-number data for the methods' parameters.
        Generally speaking,
        because Java represents real literals such as 98.6 as <c>double</c>, 
        the <c>double</c> type is more widely used than <c>float</c>. 
        Moreover, using <c>double</c> wherever a floating point value is 
        needed will cut down on the number of implicit data 
        conversions that a program would have to perform.
        Therefore, each of our conversion methods should take 
        a <c>double</c> parameter and return a <c>double</c> result.
      </p>
      <principle>
        <title>PROGRAMMING TIP: Numeric Types</title>
        <p>
          Java uses the <c>int</c> type for integer literals and <c>double</c> for real-number literals.
          Therefore using <c>int</c> and <c>double</c> for numeric 
          variables and parameters reduces the number of implicit conversions 
          a program would have to perform.
        </p>
      </principle>
      <p>
        These considerations lead to the design shown in <xref ref="fig-temperatureUML">Figure</xref>.
      </p>
      <figure xml:id="fig-temperatureUML">
        <caption>The Temperature class.</caption>
       <image width="50%" source="chptr05/temp-uml.png"/>
      </figure>
<!--
    </subsubsection>
    <subsubsection>
      <title>Implementation: <c>Temperature</c></title>
-->  
<paragraphs><title>Implementation: <c>Temperature</c></title></paragraphs>
      <p>
        The implementation of the <c>Temperature</c> class is shown in 
        <xref ref="fig-temperature">Figure</xref>.
      </p>
     <figure xml:id="fig-temperature">
        <caption>The <c>Temperature</c> class.</caption>
        <program language="java"><input>
          public class Temperature
          {
              public static double fahrToCels(double temp)
              {
                  return (5.0 * (temp - 32.0) / 9.0);
              }
              public static double celsToFahr(double temp)
              {
                  return (9.0 * temp / 5.0 + 32.0);
              }
          } // Temperature
        </input></program>
      </figure>
      <p>
        Note that because <c>celsToFahr()</c> uses the <c>double</c> value <c>temp</c> in its calculation,
        it uses floating-point literals (9.0, 5.0, and 32.0) in its conversion expression.
        This helps to reduce the reliance on Java's built-in promotion rules,
        which can lead to subtle errors.
        For example,
        suppose we had written the <c>celsToFahr()</c> method using this calculation:
      </p>
      <program language="java"><input>
        return (9 / 5 * temp + 32);    // Error: equals (temp + 32)
      </input></program>
      <p>
        Because 9 divided by 5 gives the integer result 1, this expression 
        is always equivalent to <c>temp + 32</c>, which is not the correct conversion formula.
        This kind of subtle semantic error can be avoided if you avoid mixing types wherever possible.
      </p>
      <principle>
        <title>PROGRAMMING TIP: Don't Mix Types</title>
        <p>
          You can reduce the incidence of semantic errors caused by implicit type conversions if,
          whenever possible,
          you explicitly change all the literals in an expression to the same type.
        </p>
      </principle>
<!--   
    </subsubsection>
    <subsubsection>
      <title>Testing and Debugging</title>
-->
<paragraphs><title>Testing and Debugging</title></paragraphs>

      <p>
        The next question to be addressed is how should this program be tested?
        As always, you should test  the program in a stepwise fashion.
        As each method is coded,
        you should test it both in isolation and in combination with the other methods,
        if possible.
      </p>
      <p>
        Also, you should develop appropriate
        <em>test data</em>.  It is not enough to just plug in any values.
        The values you use should test for certain potential problems.
        For this program, the following tests are appropriate:
        <ul>
          <li>
            <p>
              Test converting 0 degrees C to 32 degrees F.
            </p>
          </li>
          <li>
            <p>
              Test converting 100 degrees C to 212 degrees F.
            </p>
          </li>
          <li>
            <p>
              Test converting 212 degrees F to 100 degrees C.
            </p>
          </li>
          <li>
            <p>
              Test converting 32 degrees F to 0 degrees C.
            </p>
          </li>
        </ul>
      </p>
      <p>
        The first two tests use the <c>celsToFahr()</c> method to 
        test the freezing point and boiling point temperatures,
        two boundary values for this problem.
        A <term>boundary value</term> is a value at the beginning 
        or end of the range of values that a variable or calculation is meant to represent.
        The second pair of tests performs similar checks with the <c>fahrToCels()</c> method.
        One advantage of using these particular values is that we know what 
        results the methods should return.
      </p>

      <activity label="TempDemo">
        <statement><p>Try the following demo of the Temperature converter.  
          Try each of the tests mentioned above.  </p></statement>
          <program language="java" interactive="activecode">
         <input>
         public class Temperature {
            
             public static double fahrToCels(double temp)
             {
                 return (5.0 * (temp - 32.0) / 9.0);
             }
             public static double celsToFahr(double temp)
             {
                 return (9.0 * temp / 5.0 + 32.0);
             }
              public static void main(String[] args) {
                  double fTemp = 32;
                  double cTemp = Temperature.fahrToCels(fTemp);
                  System.out.println(fTemp + "F is " + cTemp + "C");
                  System.out.println("0 in C is " + Temperature.celsToFahr(0) + "F");
             }
         }
        </input>
        </program>
        </activity>

      <principle>
        <title>EFFECTIVE DESIGN: Test Data</title>
        <p>
          Developing appropriate test data is an important part of program design.
          One type of test data should check the boundaries of the particular calculations you are making.
        </p>
      </principle>
      <principle>
        <title>DEBUGGING TIP: Test, Test, Test!</title>
        <p>
          The fact that your program runs correctly on some data is no guarantee of its correctness.
          The more testing,
          and the more careful the testing you do, the better.
        </p>
      </principle>
<!--      
    </subsubsection>
    <subsubsection xml:id="tempui">
      <title>The <c>TemperatureUI</c>Class</title>
-->
   <paragraphs><title>The <c>TemperatureUI</c> Class</title></paragraphs>

      <p>
        The purpose of the <c>TemperatureUI</c> class is to serve as a user interface<mdash/>that is,
        as an interface between the user and a <c>Temperature</c> object.
        It will accept a Fahrenheit or Celsius temperature from the user,
        pass it to one of the public methods of the <c>Temperature</c> object for conversion,
        and display the result that is returned.
      </p>
      <p>
        As we discussed in Chapter<nbsp/>4,
        the user interface can take various forms,
        ranging from a command-line interface to a graphical interface.
        <xref ref="fig-tempcmdline">Figure</xref>
        shows a design for the user interface based on the command-line 
        interface developed in Chapter<nbsp/>4.
        The <c>TemperatureUI</c> uses a <c>KeyboardReader</c> to 
        handle interaction with the user and uses <c>static</c> methods in the
        <c>Temperature</c> class to perform the temperature conversions.
      </p>
      <figure xml:id="fig-tempcmdline">
        <caption>A command-line user interface.</caption>
        <image width="73%" source="chptr05/tempui.png"/>
      </figure>
</subsection>

